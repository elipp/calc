#include <stdio.h>

#include "fp_t.h"
#include "termtree.h"
#include "string_allocator.h"
#include "tables.h"
#include "commands.h"

typedef struct {
	char* expr;
	long double result;
} test_t;

// correct results gathered from wolframalpha
static const test_t tests[] = {
{ "(5+1*2)-23^2+1", -521 },
{ "sin(e*sin(sinh(pi/2)))", 0.8987498494059207598786L },
{ "fact(54/6) + 1/2", 362880.5L },
{ "(2.1)^(-1.2)", 0.410522387808581614598L },
{ "(e)^(2*pi+2*e)", 122976.5497941034940L },
{ "e^(2*pi+2*e)", 122976.5497941034940L },
{ "sin(sin(sin(-1.0)))", -0.6784304773607L },
{ "2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1", 98.106989259719L },
{ "-(1.35*3*sin(2))/(2+1)", -1.227551526214670L },
{ "-sin(5 + sin( cos(2.0)/2.0))", 0.996718399031256L },
{ "sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*log10(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*sin(31*cos(445)))", -65.4999835337342775L },

{ "(sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*sin(31*cos(445))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
+ (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))\
- (sin(0.3*pi^3)^3*2  / 31.31+531*(-999*33.25/833-1*e*ln(20/tan(20)) - (e/pi+1)^2/3.33)/(301.3+53*(sin(31*cos(445)))))", 0.0L },

{ "(2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
- (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)\
+ (2*((25+((532+1)/2^2)+2.1*2*3/(1.0-2.0)*sin(1.53)))/3.0 + 1)", 98.106989259719L }

};


#define REPORT(got, should_be) do { printf("got\t\t%.14Lg\nshould be\t%.14Lg\n\n", got, should_be); } while(0)

static const long double threshold = 0.000001L;

int main(int argc, char* argv[]) {
	static const size_t tests_size = sizeof(tests)/sizeof(tests[0]);
	int i = 0;
	int passed = 0;
	set_precision(PRECISION_BITS_INITIAL);
	setup_constants();

	puts("calc: Running a (very) small test suite, testing the parser for correctness, not accuracy.\n\n");
	fp_t our_result;
	fp_t_construct(&our_result);

	while (i < tests_size) {
		sa_clearbuf();
		printf("expr: \"%s\"\n", tests[i].expr);

		if (!parse_mathematical_input(tests[i].expr, &our_result)) {
			//nop
		}

		long double resld = fp_t_to_ld(our_result);
		REPORT(resld, tests[i].result);
		long double delta = (tests[i].result) - resld;

		if (fabsl(delta) > threshold) {
			printf("\033[1;31mFAIL! (result delta exceeded rough threshold value %f!)\033[m\n", (double)threshold);
		} else { 
			puts("\033[1;32mPASS. :)\033[m\n");
			++passed; 
		}
		++i;
//		free(current_expr);	// will leak, but hey; its a test program :D
		printf("\n");
	}
	
	fp_t_destroy(&our_result);

	printf("RESULTS:\npassed: %d\ntotal:  %lu.\n", passed, tests_size); 
	return 0; 
}
